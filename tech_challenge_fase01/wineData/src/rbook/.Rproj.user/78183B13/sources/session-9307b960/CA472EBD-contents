---
code-fold: true
editor: 
  markdown: 
    wrap: sentence
tbl-cap-location: bottom
---

```{css, echo = FALSE}
.justify {
  text-align: justify !important
}
```


# Análise da série em frequência anual

<div style="text-align: justify"> 


```{r import_libs}
#| echo: false
#| message: false
#| warning: false

source('utils.R')

```

```{r, read_data_yearly}
#| echo: false
#| message: false
#| warning: false
#| cache: true
 

# Lê os dados de entrada

ts_tbl <-
    readr::read_delim(
        "../../data/EXP_VINHO_2000_2022_20231118_anual.csv",
        delim = ";",
        escape_double = FALSE,
        trim_ws = TRUE,
        show_col_types = F
    )
```


Nesta seção a análise da série será realizada considerando os dados em frequência anual, conforme disposto na tabela @tbl-ts_input_yearly.

:::{#tbl-ts_input_yearly}
```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-ts_input_yearly
#| tbl-cap: ""

# Transformação do dataframe original para padronizar e facilitar a manipulação
# Foi criada uma coluna `date` no formato correspondente a partir das colunas `Ano` e `Mês`      
ts_tbl <-
    ts_tbl |> mutate(date = lubridate::make_date(Ano,12,1)) |>
    rename(value = `Valor FOB (US$)`) |>
    rename(volume = `Quilograma Líquido`) |>
    rename(country = `Países`) |>
    select(c(date, country, value, volume))  


tbl_render(ts_tbl,"")

```
Série dos dados anuais de volume e valor de vinho exportado pelo Brasil - 2000 a 2022.
:::

</div>

## Séries anuais em valores totais (corte longitudinal)

<div style="text-align: justify"> 


:::{#tbl-ts_total}
```{r transform_data}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-ts_total
#| tbl-cap: ""

ts_total <- ts_tbl |> group_by(date) |> 
            summarise(value = sum(value), 
                      volume = sum(volume)) |> 
            arrange(desc(date))

tbl_render(ts_total, "")
```
Série dos dados agregados por ano (corte longitudinal em termos totais)
:::


</div>

## Ajuste das séries para considerar os efeitos da inflação

<div style="text-align: justify"> 

Os dados monetários desta série são anuais e estão em US\$.
Como a ideia é realizar a análise dos dados ao longo do tempo, é importante considerar os efeitos da inflação pois, US\$ 1,00 em 2000 é diferente de US\$ 1,00 em 2022.
Ou seja, caso não se faça a correção pela inflação, haverá imprecisão nos valores apresentados.
Ademais, ao se relacionar os valores de exportação com dados socioeconômicos, é importante que os dados estejam na mesma data de referência.
Ainda que façamos tal ajuste, ainda resta dúvida quanto à data-base precisa, pois tal informação não foi encontrada em qualquer das fontes de dados.
Neste sentido, assumimos que os valores da série são nominais, isto é, os valores são relativos ao ano corrente.
Então todos eles foram reajustados para o ano de 2022.

Para realizarmos o ajuste foi extraída a série de [CPI](https://www.bls.gov/cpi/) (*Consumer Price Index*) anual, que é o índice de inflação dos Estados Unidos.
O gráfico abaixo demonstra que entre 2000 e 2022 houve um **crescimento acumulado do índice na ordem de aproximadamente 52%**.

```{r read_cpi}

#| echo: false
#| message: false
#| warning: false

cpi_us <-  readr::read_delim(
        "../../data/cpi_brazil_us/cpi_series.csv",
        delim = ";",
        escape_double = FALSE,
        trim_ws = TRUE,
        show_col_types = F
    ) |> arrange(desc(year))
correction <- (1./(cpi_us$cpi/cpi_us$cpi[1]))


ts_total <-
  ts_total |> dplyr::mutate(index = correction) |>
  dplyr::mutate(value_correc = value * index)

```

O gráfico abaixo mostra as série de valor de vinho exportado tanto em termos nominais como em valores de 2022.
Claramente existe uma diferença não desprezível entre os valores nominais e o valores reajustados a preços de 2022.
Por exemplo, o valor total exportado em no ano 2000 em termos nominais soma o montante de US/\$3.412.459,00, enquanto que a preços de 2022, o valor totaliza US/\$5.799.495,87.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: plt-ts_total_corrected


matplot(ts_total$date, 
        cbind(ts_total$value/10^6,ts_total$value_correc/10^6), 
        type = "l", lty = c(2,1), lwd = c(1,2), ylab = "US$ (milhões)", 
        xlab = "Ano", main = "Valor total exportado (em milhões) - US$ nominal e US$ de 2022.",
        col = c("black","blue"))
legend("topright", legend = c("US$ nominal", "US$ (2022)"), col = c("black","blue"), 
       lty = c(2,1), lwd = c(1,2))



# p1 <- qplot(date, value, data = ts_total) +  geom_point() + theme(legend.position = 'top')
# p2 <- qplot(date, value_correc, data=ts_total) +  geom_point() + theme(legend.position = 'top')
# library(patchwork)
# p1 / p2
#ts_total |> ggplot(aes(x = date, y = value)) + geom_line() + geom_dotplot(aes(y = value_correc))
#ts_total |> ggplot(aes(x = date, y = value_correc)) + geom_line()
```

Finalmente, a tabela @tbl-ts_total_corrected mostra os valores exportados tanto em termos nominais como em valores de 2022, bem como o volume exportado por ano.

:::{#tbl-ts_total_corrected}
```{r}
#| echo: false
#| message: false
#| warning: false
#| label: tbl-ts_total_corrected

ts_total <- ts_total |> 
  dplyr::select(c(date, value_correc, volume))|> 
  rename(value = value_correc)

tbl_render(ts_total, 
  "")

```
Série dos dados agregados por ano (corte longitudinal em termos totais, com valores corrigidos para o ano de 2022).
:::

Doravante, quando nos referirmos ao valor total exportado, **estaremos tratando do valor em US\$ reajustado a preços de 2022**.

</div>


## Visualização das séries temporais

<div style="text-align: justify"> 


Primeiramente visualizamos a série temporal do valor total exportado por ano entre 2000 e 2022 (@fig-ts_total_value).

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-ts_total_value
#| fig-cap: "Valor Total exportado (anual) em US$"

ts_total |> 
    plot_time_series(date, value, .smooth = T, 
                     .interactive = T, 
                     .smooth_span = 0.3,
                     .title = 'Valor Total exportado (anual) em US$',
                     .plotly_slider = T)

```

Em seguida, podemos visualizar a série de volume total exportado em base anual, considerando 1L=1Kg (@fig-ts_total_volume).

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-ts_total_volume
#| fig-cap: 'Volume Total exportado (anual) em L'

ts_total |> 
    plot_time_series(date, volume, .smooth = T, 
                     .interactive = T, 
                     .smooth_span = 0.3,
                     .title = 'Volume Total exportado (anual) em L',
                     .plotly_slider = T)


```


</div>

## Autocorrelação e Autorrelação parcial

<div style="text-align: justify"> 


A autocorrelação e a autocorrelação parcial são medidas de associação entre valores de séries atuais e anteriores. Elas indicam quais valores de série anteriores são mais úteis para prever valores futuros.

A autocorrelação parcial é a correlação entre as observações em uma série temporal que não é contabilizada por todos os intervalos mais curtos entre essas observações. Por exemplo, a autocorrelação parcial para um lag de 6 é apenas a correlação que não é contabilizada por lags de 1 a 5.

A autocorrelação é quando comparamos o valor do presente com valores do passado da mesma série.
A autocorrelação é um tipo de dependência temporal.
É comum quando os valores podem ser ordenados no tempo (com dados de séries temporais) ou no espaço (com dados espaciais)

Para a série de *valor total exportado* temos os seguintes gráficos de ACF e PACF, considerando 48 defasagens (fig-acf_pacf_total_value):

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-acf_pacf_total_value
#| fig-cap: 'Valor total exportado - ACF e PACF.'


ts_total |> plot_acf_diagnostics(date, value, .interactive = T, .lags = 1:48,
                                 .title = 'Valor total exportado - ACF e PACF.')

```

Nos gráficos acima, as decomposições mostram que existem autocorrelação e autocorrelação parcial estatisticamente significativas na primeira defasagem.

Para a série de *volume total exportado* temos os seguintes gráficos de ACF e PACF, considerando 48 defasagens (@fig-acf_pacf_total_vol):

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-acf_pacf_total_vol
#| fig-cap: 'Volume total exportado - ACF e PACF.'

ts_total |> plot_acf_diagnostics(date, volume, .interactive = T, .lags = 1:48,
                                 .title = 'Volume total exportado - ACF e PACF.')

```

Nos gráficos acima, as decomposições mostram que não existem autocorrelação e autocorrelação parcial estatisticamente significativas para a série de volume exportado .


</div>

## Decomposição sazonal

<div style="text-align: justify"> 


A decomposição da série de *valor total exportado* em suas componentes de tendência, sazonalidade e resíduos demonstra que existe uma queda expressiva no valor total exportado nos meses de janeiro, a qual corresponde a um fenômeno sazonal (@fig-acf_pacf_total_val_decomp).
Por outro lado, a tendência desde o ano 2000 é de *crescimento no valor total exportado em US\$*.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-acf_pacf_total_val_decomp
#| fig-cap: 'Decomposição da série de valor total exportado (em US$)'

ts_total |> 
    plot_stl_diagnostics(
        date, value,
        .feature_set = c("observed", "season", "trend", "remainder"),
        .trend = "auto",
        .frequency = "auto",
        .interactive = T,
        .title = 'Decomposição da série de valor total exportado (em US$)'
    )

```

A análise da decomposição da série de *volume total exportado*, como esperado, acompanha a retração no volume exportado nos mês de janeiro (@fig-acf_pacf_total_vol_decomp).
Por outro lado, é interessante notar que, em termos de volume total exportado, existiu uma mudança de tendência.
Entre o início de 2000 e o final de 2014 a tendência no volume total exportado era de queda.
Contudo, houve reversão dessa tendência em 2015.
*O que explica a reversão de tendência?*

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-acf_pacf_total_vol_decomp
#| fig-cap: 'Decomposição da série de volume total exportado (em L)'

ts_total |> 
    plot_stl_diagnostics(
        date, volume,
        .feature_set = c("observed", "season", "trend", "remainder"),
        .trend = "auto",
        .frequency = "auto",
        .interactive = T,
        .title = 'Decomposição da série de volume total exportado (em L)'
    )

```

Para avaliar melhor o comportamento observado no mês de janeiro, podemos realizar ainda uma avaliação mais precisa do "efeito calendário".

Primeiramente observamos a série de *valor total exportado*.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-total_val_seas_diag
#| fig-cap: 'Valor total exportado (em US$) - diagnóstico sazonal.'


ts_total |> 
    plot_seasonal_diagnostics(date, value, 
                              .interactive = T, 
                              .feature_set = c("quarter","year"),
                              .geom_outlier_color="#fc3503",
                              .title = 'Valor total exportado (em US$) - diagnóstico sazonal.')
```


Em seguida observamos a série de *volume total exportado*.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-total_vol_seas_diag
#| fig-cap: 'Volume total exportado (em L) - diagnóstico sazonal.'



ts_total |> 
    plot_seasonal_diagnostics(date, volume, 
                              .interactive = T, 
                              .feature_set = c("quarter","year"),
                              .geom_outlier_color="#fc3503",
                              .title = 'Volume total exportado (em L) - diagnóstico sazonal.')
```

</div>

## Teste de raiz unitária

<div style="text-align: justify"> 


```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-unit_root1


ts <- ts_total |> dplyr::select(c(date,value))

ts <- ts(ts$value,frequency=1, start=c(2000), end=c(2022))

# não rejeita a estacionariedade
adf_test <- urca::ur.df(ts, type = "trend", lags = 6, selectlags = "AIC")
adf_test@cval
adf_test@teststat

# não rejeita a estacionariedade
kpss_test <- urca::ur.kpss(ts, type = "tau", lags = "short")
kpss_test@cval
kpss_test@teststat

fit <- forecast::auto.arima(ts)
forecast::checkresiduals(fit)
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-strucchange1

fs <- strucchange::efp(ts ~ 1)
strucchange::sctest(fs)
strucchange::breakpoints(ts ~ 1)

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-unit_root2

ts <- ts_total |> dplyr::select(c(date,volume))

ts <- ts(ts$volume,frequency=1, start=c(2000), end=c(2022))

# rejeita H0 - H0:possui raiz-unitária (não é estacionária)
adf_test <- urca::ur.df(ts, type = "drift", lags = 6, selectlags = "AIC")
adf_test@cval
adf_test@teststat

# não rejeita H0 - H0:não possui raiz-unitária (é estacionária)
kpss_test <- urca::ur.kpss(ts, type = "mu", lags = "short")
kpss_test@cval
kpss_test@teststat

fit <- forecast::auto.arima(ts)
forecast::checkresiduals(fit)
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-strucchange2


fs <- strucchange::efp(ts ~ 1)
strucchange::sctest(fs)
strucchange::breakpoints(ts ~ 1)

```

</div>
